## Trees1. Binary Tree (BT) -> Binary Search Tree (BST) -> Balance Binary Search Tree (AVL and Red-Black Tree)2. Binary Tree -> Full Binary Tree (满二叉树), Complete Binary Tree (完全二叉树)3. Implementation: Binary Tree, Binary Search Tree4. Basic operations in Trees  * Tree traversal: pre-order, in-order, post-order5. Baisc techniques in Trees: traveral + recursive methods## Trie (前缀树 or 字典树)## Heaps or Binary Heaps(二叉堆， 也是一种完全二叉树，数组实现)## GraphsBasic operations in Graphs1. DFS (recursive)	```C	void DFS(Node v) {		v.visited = True;		for (Node r in v.adjacent) {			if (r.visited==False) {				DFS(r);			}		}	}	```2. BFS (implement using a queue)	```C	void BFS(Node v) {		Queue q = new Queue();		root.visited = True;		q.push(root);		while(!q.isEmpty()) {			Node r = q.front();			q.pop();			for (Node j in r.adjacent) {				if(j.visited==False) {					j.visited = True;					q.push(j);				}			}		}	}	```### 4.1 Implement a function to check if a binary tree is balanced. Here a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one. Solution:1. Traverse all nodes, to check the height of each node's left subtree and right subtree### 4.2 Given a directed graph, design an algorithm to find out whether there is a path between two nodes.Solution:1. Start with node 1, then DFS or BFS to see whether we can vist node 2. If not, then start with node 2, then DFS or BFS again. ### 4.3 Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a binary search tree with minimal height.Solution:1. To ensure the BST has minimal height, the number of nodes in left subtree should match the number of nodes in right subtree as much as possible. So first, put the middle element as the root, the elements less than the middle element become the left subtree, the elements larger than the middle element become the right subtree. Then recurse for the left and right subtrees.### 4.4 Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth (e.g., if you have a tree with depth D, you'll have D linked lists).Solution:1. We can use a level-by-level traversal to get the elements at each depth, then construct the linked lists.### 4.5 Implement a function to check if a binary tree is a binary search tree.Solution:1. Traverse all nodes, to check the max of each node's left subtree and the min of right subtree. If max < node value < min, then this node is good. If all nodes are good, then the tree is a BST. ### 4.6 Write an algorithm to find the 'next' node (i.e., in-order successor) of a given node in a binary search tree. You may assume that each node has a link to its parent.Solution:1. Notice the order of in-order traversal. left subtree -> node -> right subtree### 4.7 Find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in a data structure. Note: This is not necessary a binary search tree. Solution:1. If the two nodes are in different side of the root (i.e., one in the left subtree, one in the right subtree), then the root is the first common ancestor of the two nodes. Otherwise, if they are both in the left subtree, let the root be the root of the left subree. If they are both in the right subtree, let the root be the root of the right subtree. Then recurse. ### 4.8 You have two very large binary trees: T1, with millions of nodes, and T2, with hundreds of nodes. Create an algorithm to decide if T2 is a subtree of T1. A tree T2 is a subtree of T1 if there exists a node in T1 such that the subtree of n is identical to T2. Solution:1. Traversal the nodes in tree T1, if the value of a node is euqal to the root of T2, then check whether the subtree with the node as the root is identical to T2. ### 4.9 You are given a binary tree in which each node contains a value. Design an algorithm to print all paths which sum to a given value. The path deoes not need to start or end at the root or a leaf. Solution:1. See the solution of the book.