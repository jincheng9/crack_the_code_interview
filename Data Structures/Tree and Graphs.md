## Trees1. Binary Tree (BT) -> Binary Search Tree (BST) -> Balance Binary Search Tree (AVL and Red-Black Tree)2. Binary Tree -> Full Binary Tree (满二叉树), Complete Binary Tree (完全二叉树)3. Basic operations in Trees  * Tree traversal: pre-order, in-order, post-order## Trie (前缀树 or 字典树)## Heaps or Binary Heaps(二叉堆， 也是一种完全二叉树，数组实现)## GraphsBasic operations in Graphs1. DFS (recursive)	```C	void DFS(Node v) {		v.visited = True;		for (Node r in v.adjacent) {			if (r.visited==False) {				DFS(r);			}		}	}	```2. BFS (implement using a queue)	```C	void BFS(Node v) {		Queue q = new Queue();		root.visited = True;		q.push(root);		while(!q.isEmpty()) {			Node r = q.front();			q.pop();			for (Node j in r.adjacent) {				if(j.visited==False) {					j.visited = True;					q.push(j);				}			}		}	}	```### 4.1 Implement a function to check if a binary tree is balanced. Here a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one. Solution:1. Traverse all nodes, to check the height of each node's left subtree and right subtree### 4.2 Given a directed graph, design an algorithm to find out whether there is a path between two nodes.Solution:1. Start with node 1, then DFS or BFS to see whether we can vist node 2. If not, then start with node 2, then DFS or BFS again. 