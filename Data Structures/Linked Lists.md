Basic operations in linked lists(a) insert(), delete(), size()Basic techniques in linked lists(a) Two-pointer (fast/slow) technique(b) Recursive method###2.1 Write code to remove duplicates from an unsorted linked list.Solution:1. Add the first element to a hash table, then check the second element, if the elementexists in the hash table, delete the element, if not, add the element to the hash table, and then check the third element, etc...FOLLOW UP Solution:1. Use two-for-loop like method to compare the elements of the linked list. One pointer iterates through the linked list, and another pointer checks all subsequent elements.###2.2 Implement an algorithm to find the kth to last element (倒数第k个) of a singly linked list.Solution:1. Traverse the linked list to get the length, and then traverse again to find the kth to last element. 2. Use two pointers. Initially, a pointer points at the first element, another pointer points at the kthelement. Then two pointers move forward, if the second pointer points at the last element (i.e., point->next = NULL),then the first pointer points at the kth to last element.###2.3 Implement an alogorithm to delete a node in the middle of a singly linked list, given only access to that node. Input: delete node c from the linked list: a->b->c->d->e, Output: a->b->d->eSolution:1. copy the data and the pointer member of the next node to that node. 	c->data = c->next->data	c->next = c->next->next### 2.4 Write code to partition a linked list around a value x, such that all nodes less than x come before all nodes greater than or equal to xSolution:1. Use two lists, one list stores the nodes less than x, another list stores the nodes greater or equal to x,and then merge these two lists. (each list has two pointers, head and tail)###2.5 You have two numbers represented by a linked list, where each node contains a single digit. The digits are stored in reverse order, such that 1's digit is at the head of the list. Write a function that adds the two  numbers and returns the sum as a linked list.Solution:1. Get the two numbers represented by the lists, and then add them, and then represent the sum as a new list.FOLLOW UP Solution:1. The same as above. ### 2.6 Given a circular linked list, implement an algorithm which returns the node at the beginning of the loop.Solution:1. Using the faster runner and slower runner technique to find the meeting point, then let slower pointerpoints at the head, keep faster pointer points at the meeting point. Then Let slower pointer and faster pointer moves one step each time. When these two pointers point at the same node, then this node is the beginning of the loop. ###2.7 Implement a function to check if a linked list is a palindrome.Solution:1. Get the reversed list, and then compare the original list with the reversed list. If they are the same,then this linked list is a palindrome. Otherwise, it is not a palindrome.2. Put the first half of the linked list into a stack, and then compare the rest of linked list with the elements in the stack, if all are the same, then the linked list is a palindrome. Remark: If the length of the list is known, it is easy. If the length is not known, we can use the fast runner and slow runner to get the first half of the linked list. We need to pay attention to the case when the lengthis odd.###Other Basic Questions:1. Reverse a list2. Sort a list